一.	分区
	程序计数器、虚拟机栈、本地方法栈、堆、方法区
	
二.	具体分区

	1.	程序计数器（Program Counter Register）
		记录当前线程执行的位置。记录位置，恢复线程操作，分支操作、循环操作、跳转、异常处理等也都需要依赖这个计数器来完成
		注意：
				1.	程序计数器不会outOfmenoryError
				2.	线程私有，每个线程都有，生命周期跟随线程
				3.	执行java方法，计数器记录正在执行的虚拟机字节码地址；执行native方法，计数器为空
	
	2.	虚拟机栈
		Java栈总是跟线程关联在一起，每当创建一个线程，JVM就回为线程分配一个Java栈空间，
		而每个Java栈又包含多个栈帧组成，用于存储局部变量表、操作栈、动态连接、方法返回地址和异常信息等。 
			1.	2种异常：
				StackOverflowError：当线程请求栈深度超出虚拟机栈所允许的深度时抛出
				OutOfMemoryError：当 Java 虚拟机动态扩展到无法申请足够内存时抛出。
			2.	jvm是基于栈的解释器执行的
					dvm是基于寄存器解释器执行的
			3.	基于栈指虚拟机栈
				虚拟机栈初衷是用来描述java方法执行的内存模型
				每个方法被执行的时候，jvm都会在虚拟机栈中创建一个栈帧
		1>	栈帧
			线程中有多个栈帧，一个方法一个栈帧，包含有局部变量表、操作数栈、动态连接、返回地址等
			1.	局部变量表
				局部变量表是变量值的存储空间，我们调用方法时传递的参数，以及在方法内部创建的局部变量都保存在局部变量表中
			2.	操作数栈
				操作栈，后入先出栈，方法刚开始是空的，方法执行中，字节码指令被压入和弹出操作数栈
			3.	动态链接
				支持方法调用过程中的动态连接，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用
			4.	返回地址
				退出方法2种方式：正常退出/异常退出
				在方法退出后都需要返回到方法被调用的位置，程序才能继续执行。而虚拟机栈中的“返回地址”就是用来帮助当前方法恢复它的上层方法执行状态
				方法正常退出时，调用者的 PC 计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理器表确定的，栈帧中一般不会保存此部分信息
	
	3.	本地方法栈
		涉及native，有些虚拟机对栈已经合二为一了，就如HotSpot
		
	4.	堆
		通过new关键字创建的对象实例，都保存在Java堆里面，这一块内存区域是GC回收的主要地方。而创建的对象的类型信息取方法区去取。 
		按照对象存储时间的不同，堆中的内存可以划分为新生代（Young）和老年代（Old）
		线程共享
		
	5.	方法区
		存储已经被 JVM 加载的类信息（版本、字段、方法、接口）、常量、静态变量、即时编译器编译后的代码和数据
		线程共享
			注意：
			1.	方法区是规范层面的东西，规定了这一个区域要存放哪些数据。
			2.	永久区或者是 metaspace 是对方法区的不同实现，是实现层面的东西。
		
	6.	异常再现
		StackOverflowError 栈溢出异常
			递归调用方法本身，会导致栈一直增加到溢出
		OutOfMemoryError 内存溢出异常
			不停的创建对象，导致堆内存不够就会溢出，或者设置很小的堆内存
	
三.	总结
	上面是大概的5块分区，具体的虚拟机实现还是不同的，Sun 公司的 HotSpot、JRocket、IBM J9、
	以及我们非常熟悉的 Android Dalvik 和 ART 都不一样
	
	主要运行时内存是堆栈，分别是：Java 虚拟机栈和本地方法栈，以及“GC堆”和方法区，程序计数器影响不是重点
	
	JVM 内存中只有堆和方法区是线程共享的数据区域，其它区域都是线程私有的。
	并且程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域