一.	描述
	程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而灭，不需要考虑处理
	堆区，方法区，运行时候才知道内存多少，所以主要回收的是这块内容
	
二.	什么是垃圾
	可达性分析法：GC Root开始，对象不可达就回收
	1.	GC ROOT 对象
		1>	Java 虚拟机栈（局部变量表）中的引用的对象。
		2>	方法区中静态引用指向的对象。
		3>	仍处于存活状态中的线程对象。
		4>	Native 方法中 JNI 引用的对象
	2.	回收时机
		1>	Allocation Failure：	堆内存不够回收
		2>	System.gc():	应用层主动调用就回收
	3.	验证GC Root 情况
		Java 命令时的参数：-Xms 初始分配 JVM 运行时的内存大小，如果不指定默认为物理内存的 1/64
		1>	虚拟机栈局部变量引用的对象 			作为GC Root验证成功
		2>	方法区中的静态变量引用的对象 		作为GC Root验证成功
		3>	活跃线程 							作为GC Root验证成功
		4>	成员变量 不是gc root							作为GC Root验证成功	
		
三.	回收垃圾
	1.	标记清除方法
		gc root保留被引用的对象，剩下的当做垃圾处理
		1>	mark 标记：	找到所有的gcroot 对象，相连的标记灰色，其他黑色
		2>	sweep 清除：	清除黑色垃圾
		优点：实现简单，不需要将对象进行移动。
		缺点：这个算法需要中断进程内其他组件的执行（stop the world），并且可能产生内存碎片，提高了垃圾回收的频率
	2.	复制算法
		内存分块，复制存活对象，清除垃圾对象
		1>	内存分A，B块,A中是正在使用的
		2>	标记存活对象，复制去B块，并设置B是使用内存
		优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。
		缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。
	3.	标记-压缩算法
		1>	Mark 标记：找到gcroot 对象与存活对象，标记灰色，其他黑色
		2>	压缩阶段：将剩余存活对象按顺序压缩到内存的某一端
		优点：这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。
		缺点：所谓压缩操作，仍需要进行局部对象移动，所以一定程度上还是降低了效率。
		
四.	分代回收策略
	1.	年轻代
		一般是复制算法，分Eden、Survivor0（简称 S0）、Survivor1（简称S1）；8：1：1
		流程：
			eden第一次满，gc,存活对象存在s0,s1没有值
			eden再满，gc,存活对象存在在s1，s0为空
			如此反复s0,s1之间切换几次之后，默认15次，还有存活，就转移到老年代中
	2.	老年代
		1>	大内存，新生代内存不足可以使用老年代，-XX:PretenureSizeThreshold 控制到底是多大
		2>	存活多次，分配老年代
		3>	老年代汇有512 byte 的 card table区域，专门存储新生代对象
	3.	GV log 分析
		参数.png，分代回收机制参考图形.png
五,	引用
	引用的4种类型.png
	1.	软引用使用
	SoftReference
	2.	软引用问题
		软引用如果被其他使用，占据，在每次gc的时候就不会被释放，导致内存爆，
		最好是软引用被存储的地方也通过队列管理，每次gc之后清除它，判断是否为null
六.	总结
	讲了垃圾回收的各种知识
七.	拓展
	1.	观察jvm的变化监控软件：
		D:\android\jdk\jdk_local\bin\jvisualvm.exe
		工具-插件-安装visual-GC
		可以再AS中写代码监控GC效果
			@org.junit.Test
			public void isCorrect() {
				ArrayList list = new ArrayList();
				while (true) {
					list.add(new TestGC());

					try {
						Thread.sleep(10);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			}

			class TestGC {
				byte[] bytes = new byte[300 * 1024];// 100k
			}