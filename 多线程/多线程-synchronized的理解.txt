1.	场景
	1>实例方法，作用于当前实例加锁（即当前对象），进入同步代码前要获得当前实例的锁
	2>静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁（任意多个对象，只要是这个类都能唯一）
	3>代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。
	
2.	synahroized原理：
		synchronized的对象锁（重量级锁），锁标识位为10，其中指针指向的是monitor对象，字节码层是 monitorenter  锁开始。onitorexit 锁结束
		如果是方法锁，则 ACC_SYNCHRONIZED 标识区分是否同步，
	
3.	锁得状态：
		无锁，偏向锁，轻量级，重量级锁 （依次递增）
	偏向锁：
		如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同
	步操作，即获取锁的过程
	轻量级锁：
		若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段
		轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁
	自旋锁：
		轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。
		这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿
		失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来
	锁消除：
		编译前，进行扫描，把不可能存在竞争的锁，删除
		
4.	synchronized
	1>synchronized的可重入性：当前类中 synchronized 方法可以调用另一个synchronized 方法，或者子类调用父类的，都是可以的
	2>线程的中断对于synchronized是无效的
	拓展：线程的中断：interrupt可以中断阻塞的线程，未阻塞的线程，加上如下判断，
	 if (this.isInterrupted()){
        System.out.println("线程中断");
        break;
     }
	3>notify/notifyAll和wait,必须在synchronized中，因为需要拿到监视器monitor对象
	seleep与wait区别：
		wait调用，线程暂停。释放监视器锁(monitor)，直到notify/notifyAll后才能执行
		sleep仅休眠，不释放锁，notify/notifyAll后不释放锁，synchronized执行完才会释放锁
	