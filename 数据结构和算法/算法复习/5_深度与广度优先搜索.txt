一.	深度优先搜索（DFS）
	原理：	从起点出发，从一个方向走，直到停止，然后尝试走另一个方向，直到终点
	DFS遍历：假设我们有这么一个图，里面有A、B、C、D、E、F、G、H 8 个顶点，点和点之间的联系如下图所示，对这个图进行深度优先的遍历
		b  ------  f --------- c
	  |	  |			| 			|
	  |	   a   ----  d			H
	  E		|
	   |	|
		  G
	解题思路：	依赖栈实现，访问一个就加入栈，直到无法访问就搜索栈顶附近有无点，没有就弹栈，一直弹，再搜索附近有无有就继续压栈
				（搜索顺序是按照字母的顺序执行）
	1.	列一：	给定一个二维矩阵代表一个迷宫，迷宫里面有通道，也有墙壁，通道由数字 0 表示，而墙壁由 -1 表示，有墙壁的地方不能通过，那么，能不能从 A 点走到 B 点
		代码实现：数组使用二维数组来表示：  2种实现都在解法中
		思路：
			递归实现：
				代码看上去很简洁；
				实际应用中，递归需要压入和弹出栈，栈深的时候会造成运行效率低下
			非递归实现：
				栈支持压入和弹出；
				栈能提高效率。
		算法分析：
			一般dfs使用图论思想，图两种表示方式：邻接表、邻接矩阵
		时间复杂度：
			邻接表
				访问所有顶点的时间为 O(V)，而查找所有顶点的邻居一共需要 O(E) 的时间，所以总的时间复杂度是 O(V + E)。
			邻接矩阵
				查找每个顶点的邻居需要 O(V) 的时间，所以查找整个矩阵的时候需要 O(V2) 的时间。
		举例：	利用 DFS 在迷宫里找一条路径的复杂度。迷宫是用矩阵表示。
			时间复杂度：	看成邻接矩阵，m行n列，顶点就是mxn个，复杂度：O(MxN)
			控件复杂度：	堆栈解决，最坏就是全部压栈，复杂度：O(MxN)
	2.	列2：	利用 DFS 去寻找最短的路径
		思路：
			1>	暴力法：	找所有离开，比较长短，
			2>	优化法：	寻找目的地，并记录到起始点距离，从某方向到达距离最少就更新，到达距离多就不尝试
		代码实现：	
		运行结果：
		
二.	广度优先搜索（BFS）