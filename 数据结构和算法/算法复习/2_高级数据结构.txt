一.	优先队列 PriorityQueue（二叉堆结构=数组+完全二叉树）
	特点：	保证每次取出的元素都是队列中优先级别最高的（规则可以是数值大小，获取其他）
	场景：	从一堆杂乱无章的数据当中按照一定的顺序（或者优先级）逐步地筛选出部分乃至全部的数据
	1.	实例：	任意一个数组，找出前 k 大的数
		思路：	1>	数组排序，找出第k大的数，复杂度是O(n)
				2>	使用有限队列，复杂度O(k+nlogk),不需要遍历所有排序，数据量大的时候就非常好
		实现：	
			优先队列性质：
				1>	数组里的第一个元素 array[0] 拥有最高的优先级别。
				2> 	给定一个下标 i，那么对于元素 array[i] 而言：
					它的父节点所对应的元素下标是 (i-1)/2
					它的左孩子所对应的元素下标是 2×i + 1
					它的右孩子所对应的元素下标是 2×i + 2
				3>	数组里每个元素的优先级别都要高于它两个孩子的优先级别
			优先队列操作一般有2个：
				1>	向上筛选
					1.	当有新的数据加入到优先队列中，新的数据首先被放置在二叉堆的底部。
					2.	不断进行向上筛选的操作，即如果发现该数据的优先级别比父节点的优先级别还要高，
						那么就和父节点的元素相互交换，再接着往上进行比较，直到无法再继续交换为止
					
					时间复杂度：由于二叉堆是一棵完全二叉树，并假设堆的大小为 k，因此整个过程其实
							就是沿着树的高度往上爬，所以只需要 O(logk) 的时间。
							
				2>	向下筛选
					1.	当堆顶的元素被取出时，要更新堆顶的元素来作为下一次按照优先级顺序被取出的对象，需要将堆底部的元素放置到堆顶，然后不断地对它执行向下筛选的操作。
					2.	将该元素和它的两个孩子节点对比优先级，如果优先级最高的是其中一个孩子，就将该元素和那个孩子进行交换，然后反复进行下去，直到无法继续交换为止。
					
					时间复杂度：整个过程就是沿着树的高度往下爬，所以时间复杂度也是 O(logk)。
					因此，无论是添加新的数据还是取出堆顶的元素，都需要 O(logk) 的时间。
		举例：有 n 个数据，需要创建一个大小为 n 的堆。
		误区：每当把一个数据加入到堆里，都要对其执行向上筛选的操作，这样一来就是 O(nlogn)。
		解法：在创建这个堆的过程中，二叉树的大小是从 1 逐渐增长到 n 的，所以整个算法的复杂度经过推导，最终的结果是 O(n)
		注意：算法面试中是不要求推导的，你只需要记住，初始化一个大小为 n 的堆，所需要的时间是 O(n) 即可
	2.	实例：	LeetCode 第 347 题：给定一个非空的整数数组，返回其中出现频率前 k 高的元素。
		示例：	car，car，book，desk，desk，desk
		思路：	
			出现前k个，明显就算使用优先队列解决
			统计词汇最佳数据结构就是哈希表，将单词key和出现次数value组成新对象构建一个优先队列即可
		解法：
			hashMap 统计字符和次数 + PriorityQueue 直接添加k个元素即可，并在最后一个元素的时候替换其最小元素
			在实例解法一
二.	图 Graph
	1.	基本知识点：
		阶（Order）、度：出度（Out-Degree）、入度（In-Degree）
		树（Tree）、森林（Forest）、环（Loop）
		有向图（Directed Graph）、无向图（Undirected Graph）、完全有向图、完全无向图
		连通图（Connected Graph）、连通分量（Connected Component）
		存储和表达方式：邻接矩阵（Adjacency Matrix）、邻接链表（Adjacency List）
		
		解释：
			无向图顶点的边叫做度，有向图顶点的边叫出度入度
			任意2个顶点的边都是无向边（没方向的边）就是无向图，无向图中任意2个顶点都有边，就是完全无向图
			任意2个顶点的边都是有向边（有方向的边）就是有向图，有向图中方向互为相反的2条狐，就是有向完全图
			任意2个顶点都是联通的，就是连通图
			邻接矩阵，存储方式用2个数组表示图，一个一维向量表示顶点，一个二维向量存储图中的边和狐信息
			邻接链表：一个存储一维数组，一个是存储链表
		
	2.	围绕图的算法：
		图的遍历：深度优先、广度优先
		环的检测：有向图、无向图
		拓扑排序
		最短路径算法：Dijkstra、Bellman-Ford、Floyd Warshall
		连通性相关算法：Kosaraju、Tarjan、求解孤岛的数量、判断是否为树
		图的着色、旅行商问题等
		
	3.	必须知道的知识点；
		图的存储和表达方式：邻接矩阵（Adjacency Matrix）、邻接链表（Adjacency List）
		图的遍历：深度优先、广度优先
		二部图的检测（Bipartite）、树的检测、环的检测：有向图、无向图
		拓扑排序
		联合-查找算法（Union-Find）
		最短路径：Dijkstra、Bellman-Ford
		
		解释：
			1>	深度优先遍历(Depth First Search)的主要思想是：
			　　1)	首先以一个未被访问过的顶点作为起始顶点，沿当前顶点的边走到未访问过的顶点；
			　　2)	当没有未访问过的顶点时，则回到上一个顶点，继续试探别的顶点，直至所有的顶点都被访问过。
			2>	广度优先遍历(Depth First Search)的主要思想是：类似于树的层序遍历
				都一个访问的是第一层，同时访问第二批，第二批访问的是第二层，同时访问第三批	
			3>	最短路径：Dijkstra 	每次操作找出距离集合外离出发点最近的点加入集合中
			4>	
	4.	实例
		LeetCode 第 785 题：给定一个无向图 graph，当这个图为二部图时返回 true。
		思路：
			判断是否二部图，需要遍历（深度/广度优先）
			二部图：
				1.	如果能将一个图的节点集合分割成两个独立的子集 A 和 B，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为二部图
				2.	图的所有顶点可以分成两个子集 U 和 V，子集里的顶点互不直接相连，图里面所有的边，一头连着子集 U 里的顶点，一头连着子集 V 里的顶点
			二部图判断流程：
				1.	给图里的顶点涂上颜色，子集 U 里的顶点都涂上红色，子集 V 里的顶点都涂上蓝色。
				2.	开始遍历这个图的所有顶点，想象一下手里握有红色和蓝色的画笔，每次交替地给遍历当中遇到的顶点涂上颜色。
				3.	如果这个顶点还没有颜色，那就给它涂上颜色，然后换成另外一支画笔。
				4.	下一个顶点，如果发现这个顶点已经涂上了颜色，而且颜色跟我手里画笔的颜色不同，那么表示这个顶点它既能在子集 U 里，也能在子集 V 里。
				5.	所以，它不是一个二部图
三.	前缀树 Trie
	场景：	广泛地运用在字典查找当中，也被称为字典树
	1>	举例：	给一系列可构成字典的字符串，要求自所有字典中找出“abc”开头的字符串
		解法：	
				1.	直接遍历所有字符，查找，时间复杂度是 O(M×N)【n个单词，m是单词平均长度】
				2.	前缀树，时间复杂度是 O(M)
		实用：
				1.	网站搜索框罗列搜索文字开头的搜索信息
				2.	汉字拼音输入法联想输出功能
		假设：	有一字典，"A"，"to"，"tea"，"ted"，"ten"，"i"，"in"，"inn"，每个单词有权重
		性质：	1.	每个节点至少包含2个基本属性
					children:	数组或者集合，罗列出每个分支当中包含的所有字符
					isEnd：		布尔值，表示该节点是否为某字符串的结尾
				2.	前缀树的根节点是空的，即只关心字典里有哪些开头的字符
				3.	除了根节点，其他所有节点都有可能是单词的结尾，叶子节点一定都是单词的结尾
		实现：	主要是创建和搜索
			1.	创建
				遍历一遍输入的字符串，对每个字符串的字符进行遍历
				从前缀树的根节点开始，将每个字符加入到节点的 children 字符集当中。
				如果字符集已经包含了这个字符，则跳过。
				如果当前字符是字符串的最后一个，则把当前节点的 isEnd 标记为真。
			还能保存额外信息，时间复杂度是O(1)
			2.	搜索
				从根节点匹配前缀字符，遇到就继续，否则返回
	2>	举例：LeetCode 第 212 题：给定一个二维网格 board 和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词
			且字母由相邻（水平/垂直）单词组成
		解法1：
			遍历字典，全面的深度优先搜索对比，不太好
		解法2：
			对比字符串的前缀，借助前缀树来重新构建字典。
	
四.	线段树 Segment Tree
	1.	举例1：	
			假设有一个数组 array[0 … n-1]， 里面有 n 个元素，现在要经常对这个数组做两件事。
			1.	更新数组元素的数值
			2.	求数组任意一段区间里元素的总和（或者平均值）
		解法1：	遍历一遍数组，时间复杂度 O(n)
		解法2：	线段树
				线段树，就是一种按照二叉树的形式存储数据的结构，每个节点保存的都是数组里某一段的总和。
				适用于数据很多，而且需要频繁更新并求和的操作。
				时间复杂度 O(logn)
	2.	举例2：	
			数组是 [1, 3, 5, 7, 9, 11]，那么它的线段树如下：
						_____36____
					_9_	|			|___27_
				_4_	|	|_5		 16_|		|_11
			1__|	|_3		  7	_|	|__9
			
		解法1：	更新数组里某个元素的数值
				从叶子节点更新到根节点，主要想寻找到叶子节点，所以复杂度是O(logn)
		解法2：	对数组某个区间段里的元素进行求和
				也是寻找操作，如果是寻找到的取件包含叶子节点区间，就得加上该节点数值，
	3.	举例3：	
			LeetCode 第 315 题：给定一个整数数组 nums，按要求返回一个新数组 counts，使得数组 counts 有该性
			质——counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量
		实例：
			输入：[5, 2, 6, 1]
			输出：[2, 1, 1, 0] 
		解释：
			5 的右侧有 2 个更小的元素（2 和 1）
			2 的右侧仅有 1 个更小的元素（1）
			6 的右侧有 1 个更小的元素（1）
			1 的右侧有 0 个更小的元素
		思路：
			线段树每个节点记录的区间是数组下标所形成的区间，然而对于这道题因为要统计的是比某个数还要小的数的总和，
			如果把分段的区间设计成按照数值的大小来划分，并记录下在这个区间中的数的总和，就能快速地知道比当前数还要小的数有多少个
			1. 首先，让从线段树的根节点开始，根节点记录的是数组里最小值到最大值之间的所有元素的总和，然后分割根节点成左区间和右区间，不断地分割下去。
			2. 初始化，每个节点记录的在此区间内的元素数量是 0，接下来从数组的最后一位开始往前遍历，每次遍历，判断这个数落在哪个区间，那么那个区间的数量加一。
			3. 遇到 1，把它加入到线段树里，此时线段树里各个节点所统计的数量会发生变化。
			4. 当前所遇到的最小值就是 1。
			5. 把 6 加入到线段树里。
			6. 求比 6 小的数有多少个，即查询线段树，从 1 到 5 之间有多少个数。
			7. 从根节点开始查询。由于所要查询的区间是 1 到 5，无法包含根节点的区间 1 到 6，所以继续往下查询。
			8. 左边，区间 1 到 3 被完全包含在 1 到 5 之间，把该节点所统计好的数返回。
			9. 右边，区间 1 到 5 跟区间 4 到 6 有交叉，继续往下看，区间 4 到 5 完全被包含在 1 到 5 之间，所以可以马上返回，并把统计的数量相加。
			10. 最后得出，在当前位置，在 6 的右边比 6 小的数只有一个。
 			通过这样的方法，每次把当前的数用线段树进行个数统计，然后再计算出比它小的数即可。算法复杂度是 O(nlogm)
	
五.	树状数组
	1.	举例：假设有一个数组 array[0 … n-1]， 里面有 n 个元素，现在要经常对这个数组做两件事。
			1.	更新数组元素的数值
			2.	求数组前 k 个元素的总和（或者平均值）
		解法1：	
			线段树。线段树能在 O(logn) 的时间里更新和求解前 k 个元素的总和
		解法 2：
			树状数组。
			该问题只要求求解前 k 个元素的总和，并不要求任意一个区间。
			树状数组可以在 O(logn) 的时间里完成上述的操作。
			相对于线段树的实现，树状数组显得更简单。
		特点
			树状数组的数据结构有以下几个重要的基本特征。
				它是利用数组来表示多叉树的结构，在这一点上和优先队列有些类似，只不过，优先队列是用数组来表示完全二叉树，而树状数组是多叉树。
				树状数组的第一个元素是空节点。
				如果节点 tree[y] 是 tree[x] 的父节点，那么需要满足条件：y = x - (x & (-x))。
		建议：
			由于树状数组所解决的问题跟线段树有些类似，所以不花篇幅进行问题的讨论。LeetCode 上有很多经典的题目可以用树状数组来解决，比如
			 LeetCode 第 308 题，求一个动态变化的二维矩阵里，任意子矩阵里的数的总和
六.	总结
	1.	优先队列
		拿来主义，直接多练习
	2.	图
		社交网络的人人关系，地图最短路径等
	3.	前缀树	
		一般是要求自己实现一个前缀树，所以需要熟练
	4.	线段树和树状数组
		如一副图片中修改像素的颜色，求解任意矩形取件的灰度平均值，就是采用二维的线段树
		