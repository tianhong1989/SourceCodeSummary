一.	优先队列 PriorityQueue（二叉堆结构=数组+完全二叉树）
	特点：	保证每次取出的元素都是队列中优先级别最高的（规则可以是数值大小，获取其他）
	场景：	从一堆杂乱无章的数据当中按照一定的顺序（或者优先级）逐步地筛选出部分乃至全部的数据
	1.	实例：	任意一个数组，找出前 k 大的数
		思路：	1>	数组排序，找出第k大的数，复杂度是O(n)
				2>	使用有限队列，复杂度O(k+nlogk),不需要遍历所有排序，数据量大的时候就非常好
		实现：	
			优先队列性质：
				1>	数组里的第一个元素 array[0] 拥有最高的优先级别。
				2> 	给定一个下标 i，那么对于元素 array[i] 而言：
					它的父节点所对应的元素下标是 (i-1)/2
					它的左孩子所对应的元素下标是 2×i + 1
					它的右孩子所对应的元素下标是 2×i + 2
				3>	数组里每个元素的优先级别都要高于它两个孩子的优先级别
			优先队列操作一般有2个：
				1>	向上筛选
					1.	当有新的数据加入到优先队列中，新的数据首先被放置在二叉堆的底部。
					2.	不断进行向上筛选的操作，即如果发现该数据的优先级别比父节点的优先级别还要高，
						那么就和父节点的元素相互交换，再接着往上进行比较，直到无法再继续交换为止
					
					时间复杂度：由于二叉堆是一棵完全二叉树，并假设堆的大小为 k，因此整个过程其实
							就是沿着树的高度往上爬，所以只需要 O(logk) 的时间。
							
				2>	向下筛选
					1.	当堆顶的元素被取出时，要更新堆顶的元素来作为下一次按照优先级顺序被取出的对象，需要将堆底部的元素放置到堆顶，然后不断地对它执行向下筛选的操作。
					2.	将该元素和它的两个孩子节点对比优先级，如果优先级最高的是其中一个孩子，就将该元素和那个孩子进行交换，然后反复进行下去，直到无法继续交换为止。
					
					时间复杂度：整个过程就是沿着树的高度往下爬，所以时间复杂度也是 O(logk)。
					因此，无论是添加新的数据还是取出堆顶的元素，都需要 O(logk) 的时间。
		举例：有 n 个数据，需要创建一个大小为 n 的堆。
		误区：每当把一个数据加入到堆里，都要对其执行向上筛选的操作，这样一来就是 O(nlogn)。
		解法：在创建这个堆的过程中，二叉树的大小是从 1 逐渐增长到 n 的，所以整个算法的复杂度经过推导，最终的结果是 O(n)
		注意：算法面试中是不要求推导的，你只需要记住，初始化一个大小为 n 的堆，所需要的时间是 O(n) 即可
	2.	实例：	LeetCode 第 347 题：给定一个非空的整数数组，返回其中出现频率前 k 高的元素。
		示例：	car，car，book，desk，desk，desk
		思路：	
			出现前k个，明显就算使用优先队列解决
			统计词汇最佳数据结构就是哈希表，将单词key和出现次数value组成新对象构建一个优先队列即可
		解法：
			hashMap 统计字符和次数 + PriorityQueue 直接添加k个元素即可，并在最后一个元素的时候替换其最小元素
			在实例解法一
二.	图 Graph
	1.	基本知识点：
		阶（Order）、度：出度（Out-Degree）、入度（In-Degree）
		树（Tree）、森林（Forest）、环（Loop）
		有向图（Directed Graph）、无向图（Undirected Graph）、完全有向图、完全无向图
		连通图（Connected Graph）、连通分量（Connected Component）
		存储和表达方式：邻接矩阵（Adjacency Matrix）、邻接链表（Adjacency List）
		
		解释：
			无向图顶点的边叫做度，有向图顶点的边叫出度入度
			任意2个顶点的边都是无向边（没方向的边）就是无向图，无向图中任意2个顶点都有边，就是完全无向图
			任意2个顶点的边都是有向边（有方向的边）就是有向图，有向图中方向互为相反的2条狐，就是有向完全图
			任意2个顶点都是联通的，就是连通图
			邻接矩阵，存储方式用2个数组表示图，一个一维向量表示顶点，一个二维向量存储图中的边和狐信息
			邻接链表：一个存储一维数组，一个是存储链表
		
	2.	围绕图的算法：
		图的遍历：深度优先、广度优先
		环的检测：有向图、无向图
		拓扑排序
		最短路径算法：Dijkstra、Bellman-Ford、Floyd Warshall
		连通性相关算法：Kosaraju、Tarjan、求解孤岛的数量、判断是否为树
		图的着色、旅行商问题等
		
	3.	必须知道的知识点；
		图的存储和表达方式：邻接矩阵（Adjacency Matrix）、邻接链表（Adjacency List）
		图的遍历：深度优先、广度优先
		二部图的检测（Bipartite）、树的检测、环的检测：有向图、无向图
		拓扑排序
		联合-查找算法（Union-Find）
		最短路径：Dijkstra、Bellman-Ford
		
		解释：
			1>	深度优先遍历(Depth First Search)的主要思想是：
			　　1)	首先以一个未被访问过的顶点作为起始顶点，沿当前顶点的边走到未访问过的顶点；
			　　2)	当没有未访问过的顶点时，则回到上一个顶点，继续试探别的顶点，直至所有的顶点都被访问过。
			2>	广度优先遍历(Depth First Search)的主要思想是：类似于树的层序遍历
				都一个访问的是第一层，同时访问第二批，第二批访问的是第二层，同时访问第三批	
			3>	最短路径：Dijkstra 	每次操作找出距离集合外离出发点最近的点加入集合中
	4.	实例
		LeetCode 第 785 题：给定一个无向图 graph，当这个图为二部图时返回 true。
		
		
		
三.	前缀树
四.	线段树
五.	树状数组